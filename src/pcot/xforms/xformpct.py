from typing import Tuple

import numpy as np
import pcot.conntypes as conntypes
import cv2 as cv

import pcot
from PyQt5.QtCore import Qt, QPoint
from PyQt5.QtGui import QColor, QPainter, QPolygon
from PyQt5.QtWidgets import QMessageBox
from pcot.calib import pct
from pcot.rois import getRadiusFromSlider
from pcot.xform import xformtype, XFormType

# modes of operation through which we proceed
POINTS = 0  # initial mode, constructing a set of 3 points to position the PCT
EDITROIS = 1  # PCT positioned and ROIs constructed, now editing them


@xformtype
class XformPCT(XFormType):
    """Locates the PCT and generates calibration coefficients"""

    def __init__(self):
        super().__init__("pct", "calibration", "0.0.0")
        self.addInputConnector("img", conntypes.IMG)
        self.autoserialise = ('brushSize', 'mode', 'pctPoints')
        # TODO output!

    def createTab(self, n, w):
        return TabPCT(n, w)

    def init(self, node):
        node.img = None
        node.data = None
        node.rgbImage = None
        node.previewRadius = None  # previewing needs the image, but that's awkward - so we stash this data in perform()
        node.brushSize = 10
        node.mode = POINTS
        node.pctPoints = []  # (x,y) tuples for screen positions of screws
        node.selPoint = -1  # selected point to move

    def perform(self, node):
        img = node.getInput(0, conntypes.IMG)

        if img is not None:
            node.previewRadius = getRadiusFromSlider(node.brushSize, img.w, img.h)
            img.setMapping(node.mapping)
            node.rgbImage = img.rgbImage()
        node.img = img

    def uichange(self, n):
        self.perform(n)


def transformPoints(points, matrix):
    """Use cv.transform to transform a list of points [[x,y],[x,y]...] with a 2x3 affine transform
    as generated by cv.affineTransform etc."""
    # first, put the data into a numpy array with a format cv.transform likes
    # with a pointless extra dimension
    points = np.float32(points).reshape(-1, 1, 2)
    # then transform and reshape losing that dimension
    points = cv.transform(points, matrix).reshape(-1, 2)
    return points


def drawCircle(cx, cy, r, matrix, painter, canvas):
    points = [
        [cx + r * np.sin(theta), cy + r * np.cos(theta)] for theta in np.arange(0, 2 * np.pi, np.pi / 32)
    ]

    points = transformPoints(points, matrix)
    points = [canvas.getCanvasCoords(*p) for p in points]
    painter.drawPolygon(QPolygon([QPoint(*p) for p in points]))


class TabPCT(pcot.ui.tabs.Tab):
    def __init__(self, node, w):
        super().__init__(w, node, 'tabpctcalib.ui')
        # set the paint hook in the canvas so we can draw on the image
        self.w.canvas.paintHook = self
        self.w.canvas.mouseHook = self
        self.w.brushSize.valueChanged.connect(self.brushSizeChanged)
        self.w.canvas.canvas.setMouseTracking(True)
        self.mousePos = None
        self.mouseDown = False
        # sync tab with node
        self.nodeChanged()

    def brushSizeChanged(self, val):
        self.mark()
        self.node.brushSize = val
        self.changed()

    def clearPressed(self):
        if QMessageBox.question(self.parent(), "Clear regions", "Are you sure?",
                                QMessageBox.Yes | QMessageBox.No) == QMessageBox.Yes:
            self.mark()
            # TODO link this to a button and make it work
            self.changed()

    # causes the tab to update itself from the node
    def onNodeChanged(self):
        # have to do canvas set up here to handle extreme undo events which change the graph and nodes
        self.w.canvas.setMapping(self.node.mapping)
        self.w.canvas.setGraph(self.node.graph)
        self.w.canvas.setPersister(self.node)

        if self.node.img is not None:
            # We're displaying a "premapped" image : this node's perform code is
            # responsible for doing the RGB mapping, unlike most other nodes where it's
            # done in the canvas for display purposes only
            self.w.canvas.display(self.node.rgbImage, self.node.img, self.node)
        self.w.brushSize.setValue(self.node.brushSize)

    # extra drawing operations
    def canvasPaintHook(self, p: QPainter):
        # unlike in the ROIs, we are drawing onto the canvas widget
        # rather than drawing on the image in perform(). Note the use of
        # getCanvasCoords to get from image to widget coords (dealing with
        # zoom and pan).
        c = self.w.canvas
        n = self.node
        if n.mode == POINTS:
            p.setPen(QColor(255, 255, 255))
            for idx, pt in enumerate(n.pctPoints):
                if idx == n.selPoint:
                    p.setPen(QColor(255, 0, 0))
                else:
                    p.setPen(QColor(255, 255, 255))
                x, y = c.getCanvasCoords(*pt)
                p.drawEllipse(x - 5, y - 5, 10, 10)

            if len(n.pctPoints) == 3:
                # we have enough points to perform the mapping!
                # we want to go from PCT into image space
                pts1 = np.float32(pct.screws)
                pts2 = np.float32(n.pctPoints)
                # get affine transform
                M = cv.getAffineTransform(pts1, pts2)

                # draw the surrounding rect by passing in points in PCT-space
                # and converting to image space

                points = [
                    [0, 0],  # note the extra level!
                    [pct.width, 0],
                    [pct.width, pct.height],
                    [0, pct.height]
                ]

                # transform points with affine transform
                points = transformPoints(points, M)
                # also impose the image->canvas transform
                points = [c.getCanvasCoords(*p) for p in points]
                # build a poly, and draw
                p.setPen(QColor(255, 255, 255))
                p.drawPolygon(QPolygon([QPoint(*p) for p in points]))

                # now draw the patches
                for x, y, r in pct.patches:
                    drawCircle(x, y, r, M, p, c)

        elif n.mode == EDITROIS:
            # we are editing ROIS
            if self.mousePos is not None and self.node.previewRadius is not None:
                # draw brush preview
                p.setPen(QColor(255, 255, 255))
                r = self.node.previewRadius / (self.w.canvas.canvas.getScale())
                p.drawEllipse(self.mousePos, r, r)

    def canvasMouseMoveEvent(self, x, y, e):
        self.mousePos = e.pos()
        n = self.node
        if n.mode == POINTS:
            if self.mouseDown:
                if n.selPoint >= 0:
                    n.pctPoints[n.selPoint] = (x, y)
                    self.changed()
                    self.w.canvas.update()

    def canvasMousePressEvent(self, x, y, e):
        self.mark()
        self.mouseDown = True
        n = self.node
        changed = False
        if n.mode == POINTS:
            # first look for an existing point
            mindist = None
            n.selPoint = -1
            for idx, pt in enumerate(n.pctPoints):
                px, py = pt
                dx = px - x
                dy = py - y
                dsq = dx * dx + dy * dy
                if dsq < 70 and (mindist is None or dsq < mindist):
                    n.selPoint = idx
                    mindist = dsq
                    changed = True
            # if no selected point, and we can do it, create a new point
            if mindist is None and len(n.pctPoints) < 3:
                n.pctPoints.append((x, y))
                changed = True

        if changed:
            self.changed()
            self.w.canvas.update()

    def canvasMouseReleaseEvent(self, x, y, e):
        self.mouseDown = False
