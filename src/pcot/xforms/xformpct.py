from collections import deque
from typing import Tuple

import numpy as np
import pcot.conntypes as conntypes
import cv2 as cv

import pcot
from PyQt5.QtCore import Qt, QPoint
from PyQt5.QtGui import QColor, QPainter, QPolygon
from PyQt5.QtWidgets import QMessageBox
from pcot.calib import pct
from pcot.rois import getRadiusFromSlider, ROIPainted
from pcot.xform import xformtype, XFormType

# modes of operation through which we proceed
POINTS = 0  # initial mode, constructing a set of 3 points to position the PCT
EDITROIS = 1  # PCT positioned and ROIs constructed, now editing them


class FloodFiller:
    def __init__(self, img):
        self.means = np.repeat(0, img.channels).astype(np.float64)
        self.img = img.img
        self.h, self.w = self.img.shape[:2]
        self.mask = np.zeros(self.img.shape[:2], dtype=np.bool)
        self.n = 0

    def _set(self, x, y):
        """set pixel and update cumulative moving means"""
        if not self.mask[y, x]:
            self.mask[y, x] = True
            self.means = (self.img[y, x] + self.n * self.means) / (self.n + 1)
            self.n += 1

    def fill(self, x, y):
        stack = [(x,y)]
        while stack:
            x,y = stack.pop()
            if self._inside(x,y):
                self._set(x, y)
                stack.append((x-1,y))
                stack.append((x+1,y))
                stack.append((x,y-1))
                stack.append((x,y+1))

    def _inside(self, x, y):
        if x < 0 or y < 0 or x >= self.w or y >= self.h:
            return False
        if self.mask[y,x]:
            return False
        # get the point we're talking about in the image
        # and see how far it is from the running mean
        if self.n > 0:
            dsq = np.sum((self.img[y, x] - self.means)**2)
            if dsq > 0.005:
                return False
        return True


def createPatchROI(n, x, y):
    """Create a ROIPainted which encompasses the coords x,y"""

    # first step - create a bool mask the same size as the image, all zeroes.

    # second step - perform a flood fill of this mask, using the image itself
    # as a reference. Fill should stop when the point about to be filled is
    # very far from the mean of the points so far.

    ff = FloodFiller(n.img)
    ff.fill(int(x), int(y))

    # TODO third step - crop down to a mask and BB, generate a ROIPainted and return.
    # can use the cropdown method in the ROI for this.
    ### TEST
    n.img.img[ff.mask] = np.repeat(1, n.img.channels)

    return None


@xformtype
class XformPCT(XFormType):
    """Locates the PCT and generates calibration coefficients"""

    def __init__(self):
        super().__init__("pct", "calibration", "0.0.0")
        self.addInputConnector("img", conntypes.IMG)
        self.autoserialise = ('brushSize', 'mode', 'pctPoints')
        # TODO output!

    def createTab(self, n, w):
        return TabPCT(n, w)

    def init(self, node):
        node.img = None
        node.data = None
        node.rgbImage = None
        node.previewRadius = None  # previewing needs the image, but that's awkward - so we stash this data in perform()
        node.brushSize = 10
        node.mode = POINTS
        # (x,y) tuples for screen positions of screws; a deque so we can rotate
        node.pctPoints = deque()
        node.selPoint = -1  # selected point to move

    def perform(self, node):
        img = node.getInput(0, conntypes.IMG)

        if img is not None:
            node.previewRadius = getRadiusFromSlider(node.brushSize, img.w, img.h)
            img.setMapping(node.mapping)
            node.rgbImage = img.rgbImage()
        node.img = img

    def uichange(self, n):
        self.perform(n)

    def generateROIs(self, n):
        """Generate the regions of interest for the colour patches. These are
        stored in a list in the same order as in pct.patches."""

        # We need to get from PCT space to image space
        pts1 = np.float32(pct.screws)
        pts2 = np.float32(n.pctPoints)
        # get affine transform
        M = cv.getAffineTransform(pts1, pts2)

        rois = []
        for idx, p in enumerate(pct.patches):
            # get patch centre, convert to image space, get xy coords.
            x, y, _ = p
            pp = np.float32([[[x, y]]])
            x, y = cv.transform(pp, M).ravel().tolist()
            rois.append(createPatchROI(n, x, y))


def transformPoints(points, matrix):
    """Use cv.transform to transform a list of points [[x,y],[x,y]...] with a 2x3 affine transform
    as generated by cv.affineTransform etc."""
    # first, put the data into a numpy array with a format cv.transform likes
    # with a pointless extra dimension
    points = np.float32(points).reshape(-1, 1, 2)
    # then transform and reshape losing that dimension
    points = cv.transform(points, matrix).reshape(-1, 2)
    return points


def drawCircle(cx, cy, r, matrix, painter, canvas):
    points = [
        [cx + r * np.sin(theta), cy + r * np.cos(theta)] for theta in np.arange(0, 2 * np.pi, np.pi / 32)
    ]

    points = transformPoints(points, matrix)
    points = [canvas.getCanvasCoords(*p) for p in points]
    painter.drawPolygon(QPolygon([QPoint(*p) for p in points]))


class TabPCT(pcot.ui.tabs.Tab):
    def __init__(self, node, w):
        super().__init__(w, node, 'tabpctcalib.ui')
        # set the paint hook in the canvas so we can draw on the image
        self.w.canvas.paintHook = self
        self.w.canvas.mouseHook = self
        self.w.brushSize.valueChanged.connect(self.brushSizeChanged)
        self.w.rotateButton.clicked.connect(self.rotatePressed)
        self.w.clearButton.clicked.connect(self.clearPressed)
        self.w.genButton.clicked.connect(self.genPressed)
        self.w.canvas.canvas.setMouseTracking(True)
        self.mousePos = None
        self.mouseDown = False
        # sync tab with node
        self.nodeChanged()

    def brushSizeChanged(self, val):
        self.mark()
        self.node.brushSize = val
        self.changed()

    def clearPressed(self):
        if self.node.mode == POINTS:
            if QMessageBox.question(self.parent(), "Clear points", "Are you sure?",
                                    QMessageBox.Yes | QMessageBox.No) == QMessageBox.Yes:
                self.mark()
                self.node.pctPoints.clear()
                self.changed()

    def rotatePressed(self):
        if len(self.node.pctPoints) == 3:
            self.mark()
            self.node.pctPoints.rotate()
            self.changed()

    def genPressed(self):
        if len(self.node.pctPoints) == 3:
            self.mark()
            self.node.type.generateROIs(self.node)
            self.node.pctPoints.clear()
            self.changed()

    # causes the tab to update itself from the node
    def onNodeChanged(self):
        # have to do canvas set up here to handle extreme undo events which change the graph and nodes
        self.w.canvas.setMapping(self.node.mapping)
        self.w.canvas.setGraph(self.node.graph)
        self.w.canvas.setPersister(self.node)

        # some buttons are disabled in some nodes..
        if self.node.mode == POINTS:
            rotateEnabled = len(self.node.pctPoints) == 3
            genEnabled = len(self.node.pctPoints) == 3
            clearEnabled = len(self.node.pctPoints) > 0
        else:
            rotateEnabled = False
            genEnabled = False
            clearEnabled = True
        self.w.clearButton.setEnabled(clearEnabled)
        self.w.genButton.setEnabled(genEnabled)
        self.w.rotateButton.setEnabled(rotateEnabled)

        if self.node.img is not None:
            # We're displaying a "premapped" image : this node's perform code is
            # responsible for doing the RGB mapping, unlike most other nodes where it's
            # done in the canvas for display purposes only
            self.w.canvas.display(self.node.rgbImage, self.node.img, self.node)
        self.w.brushSize.setValue(self.node.brushSize)

    # extra drawing operations
    def canvasPaintHook(self, p: QPainter):
        # unlike in the ROIs, we are drawing onto the canvas widget
        # rather than drawing on the image in perform(). Note the use of
        # getCanvasCoords to get from image to widget coords (dealing with
        # zoom and pan).
        c = self.w.canvas
        n = self.node
        if n.mode == POINTS:
            p.setPen(QColor(255, 255, 255))
            for idx, pt in enumerate(n.pctPoints):
                if idx == n.selPoint:
                    p.setPen(QColor(255, 0, 0))
                else:
                    p.setPen(QColor(255, 255, 255))
                x, y = c.getCanvasCoords(*pt)
                p.drawEllipse(x - 5, y - 5, 10, 10)

            if len(n.pctPoints) == 3:
                # we have enough points to perform the mapping!
                # we want to go from PCT into image space
                pts1 = np.float32(pct.screws)
                pts2 = np.float32(n.pctPoints)
                # get affine transform
                M = cv.getAffineTransform(pts1, pts2)

                # draw the surrounding rect by passing in points in PCT-space
                # and converting to image space

                points = [
                    [0, 0],  # note the extra level!
                    [pct.width, 0],
                    [pct.width, pct.height],
                    [0, pct.height]
                ]

                # transform points with affine transform
                points = transformPoints(points, M)
                # also impose the image->canvas transform
                points = [c.getCanvasCoords(*p) for p in points]
                # build a poly, and draw
                p.setPen(QColor(255, 255, 255))
                p.drawPolygon(QPolygon([QPoint(*p) for p in points]))

                # now draw the patches
                for x, y, r in pct.patches:
                    drawCircle(x, y, r, M, p, c)

        elif n.mode == EDITROIS:
            # we are editing ROIS
            if self.mousePos is not None and self.node.previewRadius is not None:
                # draw brush preview
                p.setPen(QColor(255, 255, 255))
                r = self.node.previewRadius / (self.w.canvas.canvas.getScale())
                p.drawEllipse(self.mousePos, r, r)

    def canvasMouseMoveEvent(self, x, y, e):
        self.mousePos = e.pos()
        n = self.node
        if n.mode == POINTS:
            if self.mouseDown:
                if n.selPoint >= 0:
                    n.pctPoints[n.selPoint] = (x, y)
                    self.changed()
                    self.w.canvas.update()

    def canvasMousePressEvent(self, x, y, e):
        self.mark()
        self.mouseDown = True
        n = self.node
        changed = False
        if n.mode == POINTS:
            # first look for an existing point
            mindist = None
            n.selPoint = -1
            for idx, pt in enumerate(n.pctPoints):
                px, py = pt
                dx = px - x
                dy = py - y
                dsq = dx * dx + dy * dy
                if dsq < 70 and (mindist is None or dsq < mindist):
                    n.selPoint = idx
                    mindist = dsq
                    changed = True
            # if no selected point, and we can do it, create a new point
            if mindist is None and len(n.pctPoints) < 3:
                n.pctPoints.append((x, y))
                changed = True

        if changed:
            self.changed()
            self.w.canvas.update()

    def canvasMouseReleaseEvent(self, x, y, e):
        self.mouseDown = False
