"""
New source tracking system - each Datum will have a source describing which input it comes from,
and each input will know how to generate useful information from that source.
"""
import math
from abc import ABC, abstractmethod
from typing import Optional, List, Set, SupportsFloat, Union, Iterable, Any, Tuple

from pcot.dataformats.pds4 import PDS4Product
from pcot.documentsettings import DocumentSettings
from pcot.filters import Filter


class SourcesObtainable(ABC):
    """Interface for all sources; we can get a set of all sources from this"""

    @abstractmethod
    def getSources(self) -> 'SourceSet':
        """get a SourceSet of all sources"""
        pass


class Source(SourcesObtainable):
    """The base class for sources, with the exception of MultiBandSource which is only used in images.
    This is abstract - the absolute minimum functionality is in NullSource."""

    @abstractmethod
    def copy(self):
        """Return a reasonably deep copy of the source"""
        pass

    def matches(self, inp, bandNameOrCWL, hasBand):
        """Returns true if the input index matches this source (if not None) and the band matches this source (if not none).
        None values are ignored, so passing "inp" of None will mean the input index is not checked.
        Default implementation matches nothing."""
        return False

    def getFilter(self):
        """return any filter"""
        return None

    def getSources(self):
        """return a set of all sources"""
        return SourceSet(self)

    def getPDS4(self):
        """If a PDS4 product, get its PDS4Product - this will have the LID"""
        return None

    @abstractmethod
    def brief(self, captionType=DocumentSettings.CAP_DEFAULT) -> Optional[str]:
        """Return a brief string to be used in captions, etc. If null, is filtered out"""
        pass

    @abstractmethod
    def long(self) -> Optional[str]:
        """Return a longer text, possibly with line breaks"""
        pass

    @abstractmethod
    def serialise(self) -> Tuple[str, Any]:
        """return type and serialisation data - deserialisation is done in SourceSet"""
        pass


def getFiltStr(filt, captionType=DocumentSettings.CAP_DEFAULT):
    if captionType == DocumentSettings.CAP_POSITIONS:  # 0=Position
        cap = filt.position
    elif captionType == DocumentSettings.CAP_NAMES:  # 1=Name
        cap = filt.name
    elif captionType == DocumentSettings.CAP_CWL:  # 2=Wavelength
        cap = str(int(filt.cwl))
    else:
        cap = f"CAPBUG-{captionType}"  # if this appears captionType is out of range.
    return cap


class FilterOnlySource(Source):
    """This is for "sources" where there isn't a source, the data has come from inside the program
    BUT there is some fictive (probably) filter data, such as sources generated by a 'gen' node."""

    def __init__(self, filtOrName=None, extraName=None):
        """Constructor takes an optional filter or name. The 'extraname' parameter is prepended to
         the source, and helps disambiguate - in a gen node, for example, it comes from the node's
         displayName."""
        self.filterOrName = filtOrName
        self.extraName = extraName

    def getFilter(self):
        return self.filterOrName if isinstance(self.filterOrName, Filter) else None

    def long(self) -> Optional[str]:
        """See above - None gets filtered out of text information"""
        pre = None if self.extraName is None else f"{self.extraName}: "
        if isinstance(self.filterOrName, Filter):
            return f"{pre}wavelength {int(self.filterOrName.cwl)}, fwhm {int(self.filterOrName.fwhm)}"
        else:
            return f"{pre}band {self.filterOrName}"

    def brief(self, captionType=DocumentSettings.CAP_DEFAULT) -> Optional[str]:
        pre = "" if self.extraName is None else f"{self.extraName}:"
        if isinstance(self.filterOrName, Filter):
            return f"{pre}{getFiltStr(self.filterOrName, captionType)}"
        else:
            return f"{pre}{self.filterOrName}"

    def copy(self):
        """not actually a copy, but this is immutable anyway"""
        return self

    def matches(self, _, filterNameOrCWL, hasFilter):
        """return true if the source matches ALL the non-None criteria"""
        if hasFilter is not None:
            if hasFilter and not self.getFilter():
                return False
            if not hasFilter and self.getFilter():
                return False
        if filterNameOrCWL:
            if isinstance(filterNameOrCWL, str):
                name = self.filterOrName.name if isinstance(self.filterOrName, Filter) else self.filterOrName
                pos = self.filterOrName.position if isinstance(self.filterOrName, Filter) else None
                if name != filterNameOrCWL and pos != filterNameOrCWL:
                    return False
            elif isinstance(filterNameOrCWL, SupportsFloat):  # this is OK, SupportsFloat is a runtime chkable protocol
                if not isinstance(self.filterOrName, Filter) \
                        or not math.isclose(filterNameOrCWL, self.filterOrName.cwl):
                    return False
        return True

    def serialise(self):
        # deserialisation is done in SourceSet

        if isinstance(self.filterOrName, Filter):
            filtorname = ('filter', self.filterOrName.serialise())
        elif isinstance(self.filterOrName, str):
            filtorname = ('name', self.filterOrName)
        else:
            raise Exception(f"cannot serialise a {type(self.filterOrName)} as a filter")

        d = {
            'filtorname': filtorname
        }
        return 'filtersource', d


class NullSource(Source):
    """This is for "sources" where there isn't a source, the data has come from inside the program AND
    there is no filter data.
    Typically this will get filtered out when we print the sources or perhaps earlier."""

    def brief(self, captionType=DocumentSettings.CAP_DEFAULT) -> Optional[str]:
        """return a brief string for use in captions - this will just return None, which will
        be filtered out when used in such captions."""
        return None

    def long(self) -> Optional[str]:
        """See above - None gets filtered out of text information"""
        return None

    def copy(self):
        """not actually a copy, but this is immutable anyway"""
        return self

    def serialise(self):
        return 'nullsource', None


class InputSource(Source):
    """A basic source for a single band of an image or a non-image value.
    This is for things which actually come from an Input, and should handle equality and hashing
    so that two sources which come from the data are equal.
    """

    # if this is an filtered image band, reference to the filter; else a string for the band name
    filterOrName: Union[Filter, str]
    method: 'InputMethod'  # the "input method" object that produced this source
    input: 'Input'  # the actual input object
    pds4: PDS4Product  # any PDS4 data

    def __init__(self, method: Optional['InputMethod'], filterOrName: Union[str, Filter], pds4: PDS4Product = None):
        """This takes an input method, and either a filter or a name. If no input method is provided, an
        nullmethod is generated."""
        self.filterOrName = filterOrName
        if method is None:
            from pcot.inputs.nullinput import NullInputMethod
            method = NullInputMethod(None)
        self.method = method
        self.pds4 = pds4
        # this is used for hashing and equality - should be the same for two identical sources
        filtID = self.filterOrName.cwl if isinstance(self.filterOrName, Filter) else self.filterOrName
        self._uniqid = f"{id(method)}/{filtID}"

    def getFilter(self):
        """return the filter if there really is one, else none"""
        return self.filterOrName if isinstance(self.filterOrName, Filter) else None

    def getPDS4(self):
        """return any associated PDS4 data"""
        return self.pds4

    def copy(self):
        return InputSource(self.method, self.filterOrName, pds4=self.pds4)

    def __eq__(self, other: Source):
        if isinstance(other, InputSource):
            return self._uniqid == other._uniqid
        else:
            return False

    def __hash__(self):
        return hash(self._uniqid)

    def __str__(self):
        """Return a full internal string representation, used in debugging"""
        return f"SOURCE-{self._uniqid}"

    def brief(self, captionType=DocumentSettings.CAP_DEFAULT) -> Optional[str]:
        """return a brief string representation, used in image captions"""
        inptxt = self.method.brief()
        if isinstance(self.filterOrName, Filter):
            cap = getFiltStr(self.filterOrName, captionType)
            return f"{inptxt}:{cap}"
        else:
            return f"{inptxt}:{self.filterOrName}"

    def long(self):
        inptxt = self.method.long()
        if isinstance(self.filterOrName, Filter):
            s = f"{inptxt}: wavelength {int(self.filterOrName.cwl)}, fwhm {int(self.filterOrName.fwhm)}"
        else:
            s = f"{inptxt}: band {self.filterOrName}"
        if self.getPDS4():
            s += f" {self.getPDS4().lid}"
        return s

    def getInputIdx(self):
        """try to work out the input index from the input - there may not be one attached to the method,
        in which case we return None"""
        if self.method.input is None:
            return None
        else:
            return self.method.input.idx

    def matches(self, inp, filterNameOrCWL, hasFilter):
        """return true if the source matches ALL the non-None criteria
        inp: the input index to match, or None
        filterNameOrCWL: the filter name or CWL to match, or None
        hasFilter: True if the source must have a filter, False if it must not, or None if it doesn't matter"""

        # if there is no input on the attached method, then we can't match an input - getInputIdx will return None
        # and we will return False
        if inp is not None and inp != self.getInputIdx():
            return False
        if hasFilter is not None:
            if hasFilter and not self.getFilter():
                return False
            if not hasFilter and self.getFilter():
                return False
        if filterNameOrCWL:
            if isinstance(filterNameOrCWL, str):
                name = self.filterOrName.name if isinstance(self.filterOrName, Filter) else self.filterOrName
                pos = self.filterOrName.position if isinstance(self.filterOrName, Filter) else None
                if name != filterNameOrCWL and pos != filterNameOrCWL:
                    return False
            elif isinstance(filterNameOrCWL, SupportsFloat):  # this is OK, SupportsFloat is a runtime chkable protocol
                if not isinstance(self.filterOrName, Filter) \
                        or not math.isclose(filterNameOrCWL, self.filterOrName.cwl):
                    return False
        return True

    def serialise(self):
        """Serialise the source. This can't serialise the InputMethod directly, so we have to rely on their
        being a document and input index to reconstruct it. That means it can't work on "orphan" input methods
        which aren't connected to a document, Input and InputManager.
        Deserialisation is done in SourceSet."""

        if isinstance(self.filterOrName, Filter):
            filtorname = ('filter', self.filterOrName.serialise())
        elif isinstance(self.filterOrName, str):
            filtorname = ('name', self.filterOrName)
        else:
            raise Exception(f"cannot serialise a {type(self.filterOrName)} as a filter")

        if self.getInputIdx() is None:
            raise Exception("cannot serialise a source without an input index")

        d = {
            'filtorname': filtorname,
            'inputidx': self.getInputIdx(),
            'pds4': None if self.pds4 is None else self.pds4.serialise()
        }
        return 'inputsource', d


class SourceSet(SourcesObtainable):
    """This is a combination of sources which have produced a single-band datum - could be a band of an
    image or some other type"""

    sourceSet: Set[Source]  # the underlying set of sources

    def __init__(self, ss: Union[Source, 'SourceSet', Iterable[Union[Source, 'SourceSet', SourcesObtainable]]] = ()):
        """The constructor takes a collection of sources and source sets, or just one, and generates a new source
        set which is  a union of all of them"""
        if isinstance(ss, Source):
            result = {ss}
        elif isinstance(ss, SourceSet):
            result = ss.sourceSet
        elif isinstance(ss, Iterable):
            result = set()
            for x in ss:
                if isinstance(x, SourcesObtainable):
                    result |= x.getSources().sourceSet
                else:
                    raise Exception(f"Bad list argument to source set constructor: {type(x).__name__}")
        else:
            raise Exception(f"Bad argument to source set constructor: {type(ss).__name__}")

        self.sourceSet = result
        self.stripNullSources()

    def stripNullSources(self):
        """Removes null sources from the set"""
        self.sourceSet = {x for x in self.sourceSet if x is not None and not isinstance(x, NullSource)}

    def add(self, other: 'SourceSet'):
        """add a source set to this one (i.e. this source set will become a union of irself and the other)"""
        self.sourceSet |= other.sourceSet
        self.stripNullSources()

    def copy(self):
        return SourceSet([x.copy() for x in self.sourceSet])

    def __str__(self):
        """internal text description; uses (none) for null sources"""
        strdata = [x.brief() for x in self.sourceSet]
        return "&".join(sorted([x if x else "(none)" for x in strdata]))

    def brief(self, captionType=DocumentSettings.CAP_DEFAULT):
        """external (user-facing) text description, skips null sources"""
        x = [x.brief(captionType) for x in self.sourceSet]
        return "&".join(sorted([s for s in x if s]))

    def long(self):
        x = [x.long() for x in self.sourceSet]
        lst = "\n".join(sorted([s for s in x if s]))
        return f"SET[\n{lst}\n]\n"

    def matches(self, inp=None, filterNameOrCWL=None, single=False, hasFilter=None, all_match=False):
        """Returns true if ANY source in the set matches ALL the criteria; or if all_match is true if ALL
        sources match the criteria:
        inp: input index
        filterNameOrCWL: either a filter name or a centre wavelength
        single: set must be a single item
        hasFilter: set must have a filter
        all_match: all items in set must match
        """
        if single and len(self.sourceSet) > 1:  # if required, ignore this set if it's not from a single source
            return False
        if len(self.sourceSet) == 0:  # if there isn't an item there can't be a match (note: all([]) == True, dammit)
            return False
        smatches = [x.matches(inp, filterNameOrCWL, hasFilter) for x in self.sourceSet]

        if all_match:
            return all(smatches)
        else:
            return any(smatches)

    ### wrappers around dunder methods of set for convenience. Could inherit set, but that's messy.
    def __len__(self):
        return len(self.sourceSet)

    def __iter__(self):
        return self.sourceSet.__iter__()

    def __contains__(self, item):
        return self.sourceSet.__contains__(item)

    def getOnlyItem(self):
        """return singleton item"""
        assert len(self.sourceSet) == 1
        e, = self.sourceSet
        return e

    def getSources(self):
        """implements SourcesObtainable"""
        return self

    def serialise(self):
        # store each source in set with its type, as a list of tuples
        return [x.serialise() for x in self.sourceSet]

    @classmethod
    def deserialise(cls, lst, document) -> 'SourceSet':
        out = []
        for tp, d in lst:
            if tp == 'nullsource':
                v = nullSource
            elif tp == 'inputsource':
                pds4 = None if d['pds4'] is None else PDS4Product.deserialise(d['pds4'])
                forntype, filtdata = d['filtorname']
                if forntype == 'filter':
                    filt = Filter.deserialise(filtdata)
                else:
                    filt = filtdata
                inidx = d['inputidx']
                # hopefully we will have loaded which methods are "active" in the inputs by now.
                inp = document.inputMgr.inputs[inidx]
                method = inp.getActive()
                v = InputSource(method,
                                filt,
                                pds4)
            elif tp == 'filtersource':
                filt = Filter.deserialise(d['filtorname'])
                v = FilterOnlySource(filt)
            else:
                raise Exception(f"Bad type in sourceset serialisation data: {tp}")
            out.append(v)
        return cls(out)


class MultiBandSource(SourcesObtainable):
    """This is an array of source sets for a single image with multiple bands; each set  is indexed by the band"""

    sourceSets: List[SourceSet]  # life is much simpler if this is public.

    def __init__(self, ss: List[Union[SourceSet, Source]] = ()):
        # turn any sources into single-element source sets
        ss = [s if isinstance(s, SourceSet) else SourceSet(s) for s in ss]
        self.sourceSets = ss

    @classmethod
    def createEmptySourceSets(cls, count):
        """Alternative constructor for when no source sets are provided: this will create an empty source set
        for each channel, given the number of channels."""
        return cls([SourceSet() for _ in range(count)])

    @classmethod
    def createBandwiseUnion(cls, lst: List['MultiBandSource']):
        """For each MultiBandSource in the list, create a new one which is a band-wise union of all of them;
        the number of bands is equal to the maximum band count of the MBSs in the list."""
        numChannels = max([len(x.sourceSets) for x in lst])  # yes, I'm using 'band' and 'channel' interchangeably.
        sets = []  # a list of SourceSets we're going to build
        for i in range(numChannels):
            # for each channel work on a new set
            newSet = SourceSet()
            for mbs in lst:
                # for each input MultiBandSource
                if i < len(mbs.sourceSets):
                    xx = mbs.sourceSets[i]
                    # add the source for that channel to the set
                    newSet.add(xx)
            sets.append(newSet)
        return cls(sets)

    def add(self, s):
        """add a band's sources to this one"""
        self.sourceSets.append(s)

    def copy(self):
        """Make a fairly deep copy of the source sets"""
        return MultiBandSource([ss.copy() for ss in self.sourceSets])

    def search(self, filterNameOrCWL=None, inp=None, single=False, hasFilter=None):
        """Given some criteria, returns a list of indices of bands whose source sets contain a member which matches
            ALL those criteria:
            filtNameOrCWL : value must match the name, position or wavelength of a filter
            inp : value must match input index
            single : there must only be a single source in the set
        """
        out = []

        # here we process things like "$_5" to get band 5 explicitly.
        if isinstance(filterNameOrCWL, str) and filterNameOrCWL.startswith('_'):
            band = filterNameOrCWL[1:]
            try:
                band = int(band)
            except ValueError:
                return []
            if band >= len(self.sourceSets):
                return []
            return [band]

        # otherwise we do the search as usual
        for i, s in enumerate(self.sourceSets):
            if s.matches(inp, filterNameOrCWL, single, hasFilter):
                out.append(i)
        return out

    def brief(self):
        """Brief text description - note, may not be used for captions."""
        out = [s.brief() for s in self.sourceSets]
        return "|".join(out)

    def long(self):
        txts = [f"{i}: {s.long()}" for i, s in enumerate(self.sourceSets)]
        s = "\n".join(txts)
        return "{\n" + s + "\n}\n"

    def getSources(self):
        """Merge all the bands' source sets into a single set (used in, for example, making a greyscale
        image, or any calculation where all bands have input)"""
        return SourceSet(set().union(*[s.sourceSet for s in self.sourceSets]))

    def serialise(self):
        return [x.serialise() for x in self.sourceSets]

    @classmethod
    def deserialise(cls, lst, document):
        lst = [SourceSet.deserialise(x, document) for x in lst]
        return cls(lst)

    def __len__(self):
        return len(self.sourceSets)

    def __iter__(self):
        return self.sourceSets.__iter__()

    def __contains__(self, item):
        return item in self.sourceSets

    def __getitem__(self, item):
        return self.sourceSets[item]


# Standard null sources: use these to avoid the creation of lots of identical objects
# when you just want a null source without filter.

nullSource = NullSource()
nullSourceSet = SourceSet(nullSource)
